"""
Property-based tests for KnowledgePiece serialization round-trip.

# Feature: agent-knowledge-base, Property 1: Data model serialization round-trip
# **Validates: Requirements 1.6**
"""
import sys
from pathlib import Path

# Path resolution for imports
_current_file = Path(__file__).resolve()
_current_path = _current_file.parent
while _current_path.name != "test" and _current_path.parent != _current_path:
    _current_path = _current_path.parent
_src_dir = _current_path.parent / "src"
if _src_dir.exists() and str(_src_dir) not in sys.path:
    sys.path.insert(0, str(_src_dir))

from hypothesis import given, settings, strategies as st

from science_modeling_tools.knowledge.models.knowledge_piece import KnowledgePiece

# Import strategies from conftest (same directory, added to sys.path)
_test_dir = Path(__file__).resolve().parent
if str(_test_dir) not in sys.path:
    sys.path.insert(0, str(_test_dir))
from conftest import knowledge_piece_strategy


# Feature: agent-knowledge-base, Property 1: Data model serialization round-trip


class TestKnowledgePieceSerializationRoundTrip:
    """Property 1: Data model serialization round-trip for KnowledgePiece.

    For any valid KnowledgePiece object, calling to_dict() then from_dict()
    on the result SHALL produce an object equivalent to the original
    (all fields match).

    **Validates: Requirements 1.6**
    """

    @given(piece=knowledge_piece_strategy())
    @settings(max_examples=200)
    def test_to_dict_from_dict_round_trip(self, piece: KnowledgePiece):
        """to_dict() followed by from_dict() produces an equivalent KnowledgePiece.

        **Validates: Requirements 1.6**
        """
        serialized = piece.to_dict()
        restored = KnowledgePiece.from_dict(serialized)

        assert restored.content == piece.content, (
            f"content mismatch: {piece.content!r} -> {restored.content!r}"
        )
        assert restored.piece_id == piece.piece_id, (
            f"piece_id mismatch: {piece.piece_id!r} -> {restored.piece_id!r}"
        )
        assert restored.knowledge_type == piece.knowledge_type, (
            f"knowledge_type mismatch: {piece.knowledge_type!r} -> {restored.knowledge_type!r}"
        )
        assert restored.info_type == piece.info_type, (
            f"info_type mismatch: {piece.info_type!r} -> {restored.info_type!r}"
        )
        assert restored.tags == piece.tags, (
            f"tags mismatch: {piece.tags!r} -> {restored.tags!r}"
        )
        assert restored.entity_id == piece.entity_id, (
            f"entity_id mismatch: {piece.entity_id!r} -> {restored.entity_id!r}"
        )
        assert restored.source == piece.source, (
            f"source mismatch: {piece.source!r} -> {restored.source!r}"
        )
        assert restored.embedding_text == piece.embedding_text, (
            f"embedding_text mismatch: {piece.embedding_text!r} -> {restored.embedding_text!r}"
        )
        assert restored.created_at == piece.created_at, (
            f"created_at mismatch: {piece.created_at!r} -> {restored.created_at!r}"
        )
        assert restored.updated_at == piece.updated_at, (
            f"updated_at mismatch: {piece.updated_at!r} -> {restored.updated_at!r}"
        )


# Feature: agent-knowledge-base, Property 2: Auto-generated piece identifiers are unique


class TestAutoGeneratedPieceIdentifiersAreUnique:
    """Property 2: Auto-generated piece identifiers are unique.

    For any collection of KnowledgePiece instances created without explicit
    piece_id values, all generated identifiers SHALL be distinct.

    **Validates: Requirements 1.2**
    """

    @given(
        contents=st.lists(
            st.text(min_size=1).filter(lambda s: s.strip()),
            min_size=2,
            max_size=50,
        )
    )
    @settings(max_examples=200)
    def test_auto_generated_ids_are_unique(self, contents):
        """Creating multiple KnowledgePieces without explicit piece_id
        produces distinct identifiers for each.

        **Validates: Requirements 1.2**
        """
        pieces = [KnowledgePiece(content=c) for c in contents]
        ids = [p.piece_id for p in pieces]
        assert len(ids) == len(set(ids)), (
            f"Duplicate piece_id found among {len(ids)} pieces: "
            f"{[pid for pid in ids if ids.count(pid) > 1]}"
        )


# Feature: agent-knowledge-base, Property 3: Tag normalization


class TestTagNormalization:
    """Property 3: Tag normalization.

    For any list of tag strings (including mixed case, leading/trailing
    whitespace, and empty strings), after KnowledgePiece construction,
    all tags SHALL be lowercase, stripped of whitespace, and non-empty
    (empty/whitespace-only strings removed).

    **Validates: Requirements 1.5**
    """

    @given(
        tags=st.lists(
            st.text(max_size=30),
            max_size=10,
        )
    )
    @settings(max_examples=200)
    def test_tags_are_normalized(self, tags):
        """After construction, all tags are lowercase, stripped, and non-empty.

        **Validates: Requirements 1.5**
        """
        piece = KnowledgePiece(content="test content", tags=tags)

        for tag in piece.tags:
            # Each tag must be lowercase
            assert tag == tag.lower(), (
                f"Tag {tag!r} is not lowercase"
            )
            # Each tag must be stripped (no leading/trailing whitespace)
            assert tag == tag.strip(), (
                f"Tag {tag!r} has leading/trailing whitespace"
            )
            # Each tag must be non-empty
            assert len(tag) > 0, "Empty tag found after normalization"

        # Empty/whitespace-only tags must be removed
        expected_tags = [t.strip().lower() for t in tags if t.strip()]
        assert piece.tags == expected_tags, (
            f"Tag normalization mismatch: input={tags!r}, "
            f"expected={expected_tags!r}, got={piece.tags!r}"
        )


# Feature: agent-knowledge-base, Property 4: Empty content rejection


class TestEmptyContentRejection:
    """Property 4: Empty content rejection.

    For any string composed entirely of whitespace characters (including
    the empty string), attempting to create a KnowledgePiece with that
    content via from_dict() SHALL raise a ValueError.

    **Validates: Requirements 1.4**
    """

    @given(
        whitespace_content=st.from_regex(r"[\s]*", fullmatch=True).filter(
            lambda s: not s.strip()
        )
    )
    @settings(max_examples=200)
    def test_empty_content_raises_value_error(self, whitespace_content):
        """from_dict() with whitespace-only content raises ValueError.

        **Validates: Requirements 1.4**
        """
        import pytest

        with pytest.raises(ValueError):
            KnowledgePiece.from_dict({"content": whitespace_content})
